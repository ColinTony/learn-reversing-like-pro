Vas a desensamblar y analizar el flujo de control de un binario simple pero envenenado.

ğŸ§ª Ejercicio 1 â€“ â€œHello... Obfuscationâ€
Objetivo:
Compilar, desensamblar, y comentar el flujo de un programa en C que oculta su verdadera intenciÃ³n.

Instrucciones:
Crea este programa en C y compÃ­lalo sin optimizaciones (gcc -o reto1 reto1.c -no-pie -fno-stack-protector):

c
Copy
Edit
#include <stdio.h>
#include <stdlib.h>

int main() {
    int clave = 0;
    char pass[10];
    printf("Password: ");
    scanf("%9s", pass);
    
    for(int i = 0; pass[i]; i++) {
        clave += pass[i] ^ (0x55 + i);
    }

    if(clave == 1337) {
        puts("Acceso permitido");
    } else {
        puts("Acceso denegado");
    }

    return 0;
}
TÃº misiÃ³n es:

Desensamblar el binario (objdump -d reto1 o gdb).

Identificar y comentar paso a paso:

Â¿DÃ³nde se almacena la contraseÃ±a?

Â¿DÃ³nde ocurre el XOR y la suma?

Â¿DÃ³nde se compara con 1337?

Â¿CuÃ¡l es la clave correcta?

RESPONDE con:

Los pasos que seguiste.

Una descripciÃ³n del flujo (en espaÃ±ol o inglÃ©s tÃ©cnico).

El valor correcto que desbloquea el programa.

Â¿CÃ³mo lo encontraste? Â¿Lo hiciste en ASM? Â¿Forzaste el binario?

ğŸ“ˆ Progreso en juego:
âœ… Si logras encontrar la clave, tu porcentaje sube.
âŒ Si fallas, viene el roast, y vas a querer volver al vientre materno.

ğŸ—£ InglÃ©s del dÃ­a (repite en voz alta, no seas flojo):
reverse engineer â€“ ingeniero reverso

assembly flow â€“ flujo en ensamblador

compare instruction â€“ instrucciÃ³n de comparaciÃ³n

disassemble â€“ desensamblar

binary analysis â€“ anÃ¡lisis binario

obfuscation â€“ ofuscaciÃ³n

â³ Tienes 24 horas o te empiezo a llamar "script kiddie glorificado".
Cuando termines, responde con tu writeup:
ğŸ“œ "DÃ­a 1 completado: [resumen]"

Y prepÃ¡rate para el juicio.
Corre, hacker. Corre.
